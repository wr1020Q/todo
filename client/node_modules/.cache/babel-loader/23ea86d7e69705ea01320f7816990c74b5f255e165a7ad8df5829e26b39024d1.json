{"ast":null,"code":"// src/MemoryLeakError.ts\nvar MemoryLeakError = class extends Error {\n  constructor(emitter, type, count) {\n    super(`Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);\n    this.emitter = emitter;\n    this.type = type;\n    this.count = count;\n    this.name = \"MaxListenersExceededWarning\";\n  }\n};\n\n// src/Emitter.ts\nvar _Emitter = class {\n  static listenerCount(emitter, eventName) {\n    return emitter.listenerCount(eventName);\n  }\n  constructor() {\n    this.events = /* @__PURE__ */new Map();\n    this.maxListeners = _Emitter.defaultMaxListeners;\n    this.hasWarnedAboutPotentialMemoryLeak = false;\n  }\n  _emitInternalEvent(internalEventName, eventName, listener) {\n    this.emit(internalEventName, ...[eventName, listener]);\n  }\n  _getListeners(eventName) {\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || [];\n  }\n  _removeListener(listeners, listener) {\n    const index = listeners.indexOf(listener);\n    if (index > -1) {\n      listeners.splice(index, 1);\n    }\n    return [];\n  }\n  _wrapOnceListener(eventName, listener) {\n    var _this = this;\n    const onceListener = function () {\n      _this.removeListener(eventName, onceListener);\n      for (var _len = arguments.length, data = new Array(_len), _key = 0; _key < _len; _key++) {\n        data[_key] = arguments[_key];\n      }\n      return listener.apply(_this, data);\n    };\n    Object.defineProperty(onceListener, \"name\", {\n      value: listener.name\n    });\n    return onceListener;\n  }\n  setMaxListeners(maxListeners) {\n    this.maxListeners = maxListeners;\n    return this;\n  }\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  getMaxListeners() {\n    return this.maxListeners;\n  }\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  eventNames() {\n    return Array.from(this.events.keys());\n  }\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  emit(eventName) {\n    for (var _len2 = arguments.length, data = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      data[_key2 - 1] = arguments[_key2];\n    }\n    const listeners = this._getListeners(eventName);\n    listeners.forEach(listener => {\n      listener.apply(this, data);\n    });\n    return listeners.length > 0;\n  }\n  addListener(eventName, listener) {\n    this._emitInternalEvent(\"newListener\", eventName, listener);\n    const nextListeners = this._getListeners(eventName).concat(listener);\n    this.events.set(eventName, nextListeners);\n    if (this.maxListeners > 0 && this.listenerCount(eventName) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {\n      this.hasWarnedAboutPotentialMemoryLeak = true;\n      const memoryLeakWarning = new MemoryLeakError(this, eventName, this.listenerCount(eventName));\n      console.warn(memoryLeakWarning);\n    }\n    return this;\n  }\n  on(eventName, listener) {\n    return this.addListener(eventName, listener);\n  }\n  once(eventName, listener) {\n    return this.addListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  prependListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners);\n      this.events.set(eventName, nextListeners);\n    } else {\n      this.events.set(eventName, listeners.concat(listener));\n    }\n    return this;\n  }\n  prependOnceListener(eventName, listener) {\n    return this.prependListener(eventName, this._wrapOnceListener(eventName, listener));\n  }\n  removeListener(eventName, listener) {\n    const listeners = this._getListeners(eventName);\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener);\n      this.events.set(eventName, listeners);\n      this._emitInternalEvent(\"removeListener\", eventName, listener);\n    }\n    return this;\n  }\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  off(eventName, listener) {\n    return this.removeListener(eventName, listener);\n  }\n  removeAllListeners(eventName) {\n    if (eventName) {\n      this.events.delete(eventName);\n    } else {\n      this.events.clear();\n    }\n    return this;\n  }\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  listeners(eventName) {\n    return Array.from(this._getListeners(eventName));\n  }\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  listenerCount(eventName) {\n    return this._getListeners(eventName).length;\n  }\n  rawListeners(eventName) {\n    return this.listeners(eventName);\n  }\n};\nvar Emitter = _Emitter;\nEmitter.defaultMaxListeners = 10;\nexport { Emitter, MemoryLeakError };","map":{"version":3,"names":["MemoryLeakError","Error","constructor","emitter","type","count","toString","name","_Emitter","listenerCount","eventName","events","Map","maxListeners","defaultMaxListeners","hasWarnedAboutPotentialMemoryLeak","_emitInternalEvent","internalEventName","listener","emit","_getListeners","Array","prototype","concat","apply","get","_removeListener","listeners","index","indexOf","splice","_wrapOnceListener","_this","onceListener","removeListener","_len","arguments","length","data","_key","Object","defineProperty","value","setMaxListeners","getMaxListeners","eventNames","from","keys","_len2","_key2","forEach","addListener","nextListeners","set","memoryLeakWarning","console","warn","on","once","prependListener","prependOnceListener","off","removeAllListeners","delete","clear","rawListeners","Emitter"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\strict-event-emitter\\src\\MemoryLeakError.ts","C:\\Users\\hinan\\todo-app\\client\\node_modules\\strict-event-emitter\\src\\Emitter.ts"],"sourcesContent":["import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n","import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}