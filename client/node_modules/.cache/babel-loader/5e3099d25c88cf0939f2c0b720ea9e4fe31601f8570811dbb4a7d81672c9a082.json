{"ast":null,"code":"import { WebSocketMemoryClientStore } from './WebSocketMemoryClientStore.mjs';\nimport { WebSocketIndexedDBClientStore } from './WebSocketIndexedDBClientStore.mjs';\nclass WebSocketClientManager {\n  constructor(channel) {\n    this.channel = channel;\n    this.store = typeof indexedDB !== \"undefined\" ? new WebSocketIndexedDBClientStore() : new WebSocketMemoryClientStore();\n    this.runtimeClients = /* @__PURE__ */new Map();\n    this.allClients = /* @__PURE__ */new Set();\n    this.channel.addEventListener(\"message\", message => {\n      if (message.data?.type === \"db:update\") {\n        this.flushDatabaseToMemory();\n      }\n    });\n    if (typeof window !== \"undefined\") {\n      window.addEventListener(\"message\", async message => {\n        if (message.data?.type === \"msw/worker:stop\") {\n          await this.removeRuntimeClients();\n        }\n      });\n    }\n  }\n  store;\n  runtimeClients;\n  allClients;\n  async flushDatabaseToMemory() {\n    const storedClients = await this.store.getAll();\n    this.allClients = new Set(storedClients.map(client => {\n      const runtimeClient = this.runtimeClients.get(client.id);\n      if (runtimeClient) {\n        return runtimeClient;\n      }\n      return new WebSocketRemoteClientConnection(client.id, new URL(client.url), this.channel);\n    }));\n  }\n  async removeRuntimeClients() {\n    await this.store.deleteMany(Array.from(this.runtimeClients.keys()));\n    this.runtimeClients.clear();\n    await this.flushDatabaseToMemory();\n    this.notifyOthersAboutDatabaseUpdate();\n  }\n  /**\n   * All active WebSocket client connections.\n   */\n  get clients() {\n    return this.allClients;\n  }\n  /**\n   * Notify other runtimes about the database update\n   * using the shared `BroadcastChannel` instance.\n   */\n  notifyOthersAboutDatabaseUpdate() {\n    this.channel.postMessage({\n      type: \"db:update\"\n    });\n  }\n  async addClient(client) {\n    await this.store.add(client);\n    await this.flushDatabaseToMemory();\n    this.notifyOthersAboutDatabaseUpdate();\n  }\n  /**\n   * Adds the given `WebSocket` client connection to the set\n   * of all connections. The given connection is always the complete\n   * connection object because `addConnection()` is called only\n   * for the opened connections in the same runtime.\n   */\n  async addConnection(client) {\n    this.runtimeClients.set(client.id, client);\n    await this.addClient(client);\n    const handleExtraneousMessage = message => {\n      const {\n        type,\n        payload\n      } = message.data;\n      if (typeof payload === \"object\" && \"clientId\" in payload && payload.clientId !== client.id) {\n        return;\n      }\n      switch (type) {\n        case \"extraneous:send\":\n          {\n            client.send(payload.data);\n            break;\n          }\n        case \"extraneous:close\":\n          {\n            client.close(payload.code, payload.reason);\n            break;\n          }\n      }\n    };\n    const abortController = new AbortController();\n    this.channel.addEventListener(\"message\", handleExtraneousMessage, {\n      signal: abortController.signal\n    });\n    client.addEventListener(\"close\", () => abortController.abort(), {\n      once: true\n    });\n  }\n}\nclass WebSocketRemoteClientConnection {\n  constructor(id, url, channel) {\n    this.id = id;\n    this.url = url;\n    this.channel = channel;\n  }\n  send(data) {\n    this.channel.postMessage({\n      type: \"extraneous:send\",\n      payload: {\n        clientId: this.id,\n        data\n      }\n    });\n  }\n  close(code, reason) {\n    this.channel.postMessage({\n      type: \"extraneous:close\",\n      payload: {\n        clientId: this.id,\n        code,\n        reason\n      }\n    });\n  }\n}\nexport { WebSocketClientManager, WebSocketRemoteClientConnection };","map":{"version":3,"names":["WebSocketMemoryClientStore","WebSocketIndexedDBClientStore","WebSocketClientManager","constructor","channel","store","indexedDB","runtimeClients","Map","allClients","Set","addEventListener","message","data","type","flushDatabaseToMemory","window","removeRuntimeClients","storedClients","getAll","map","client","runtimeClient","get","id","WebSocketRemoteClientConnection","URL","url","deleteMany","Array","from","keys","clear","notifyOthersAboutDatabaseUpdate","clients","postMessage","addClient","add","addConnection","set","handleExtraneousMessage","payload","clientId","send","close","code","reason","abortController","AbortController","signal","abort","once"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\msw\\src\\core\\ws\\WebSocketClientManager.ts"],"sourcesContent":["import type {\n  WebSocketData,\n  WebSocketClientConnection,\n  WebSocketClientConnectionProtocol,\n} from '@mswjs/interceptors/WebSocket'\nimport { WebSocketClientStore } from './WebSocketClientStore'\nimport { WebSocketMemoryClientStore } from './WebSocketMemoryClientStore'\nimport { WebSocketIndexedDBClientStore } from './WebSocketIndexedDBClientStore'\n\nexport type WebSocketBroadcastChannelMessage =\n  | {\n      type: 'extraneous:send'\n      payload: {\n        clientId: string\n        data: WebSocketData\n      }\n    }\n  | {\n      type: 'extraneous:close'\n      payload: {\n        clientId: string\n        code?: number\n        reason?: string\n      }\n    }\n\n/**\n * A manager responsible for accumulating WebSocket client\n * connections across different browser runtimes.\n */\nexport class WebSocketClientManager {\n  private store: WebSocketClientStore\n  private runtimeClients: Map<string, WebSocketClientConnectionProtocol>\n  private allClients: Set<WebSocketClientConnectionProtocol>\n\n  constructor(private channel: BroadcastChannel) {\n    // Store the clients in the IndexedDB in the browser,\n    // otherwise, store the clients in memory.\n    this.store =\n      typeof indexedDB !== 'undefined'\n        ? new WebSocketIndexedDBClientStore()\n        : new WebSocketMemoryClientStore()\n\n    this.runtimeClients = new Map()\n    this.allClients = new Set()\n\n    this.channel.addEventListener('message', (message) => {\n      if (message.data?.type === 'db:update') {\n        this.flushDatabaseToMemory()\n      }\n    })\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('message', async (message) => {\n        if (message.data?.type === 'msw/worker:stop') {\n          await this.removeRuntimeClients()\n        }\n      })\n    }\n  }\n\n  private async flushDatabaseToMemory() {\n    const storedClients = await this.store.getAll()\n\n    this.allClients = new Set(\n      storedClients.map((client) => {\n        const runtimeClient = this.runtimeClients.get(client.id)\n\n        /**\n         * @note For clients originating in this runtime, use their\n         * direct references. No need to wrap them in a remote connection.\n         */\n        if (runtimeClient) {\n          return runtimeClient\n        }\n\n        return new WebSocketRemoteClientConnection(\n          client.id,\n          new URL(client.url),\n          this.channel,\n        )\n      }),\n    )\n  }\n\n  private async removeRuntimeClients(): Promise<void> {\n    await this.store.deleteMany(Array.from(this.runtimeClients.keys()))\n    this.runtimeClients.clear()\n    await this.flushDatabaseToMemory()\n    this.notifyOthersAboutDatabaseUpdate()\n  }\n\n  /**\n   * All active WebSocket client connections.\n   */\n  get clients(): Set<WebSocketClientConnectionProtocol> {\n    return this.allClients\n  }\n\n  /**\n   * Notify other runtimes about the database update\n   * using the shared `BroadcastChannel` instance.\n   */\n  private notifyOthersAboutDatabaseUpdate(): void {\n    this.channel.postMessage({ type: 'db:update' })\n  }\n\n  private async addClient(client: WebSocketClientConnection): Promise<void> {\n    await this.store.add(client)\n    // Sync the in-memory clients in this runtime with the\n    // updated database. This pulls in all the stored clients.\n    await this.flushDatabaseToMemory()\n    this.notifyOthersAboutDatabaseUpdate()\n  }\n\n  /**\n   * Adds the given `WebSocket` client connection to the set\n   * of all connections. The given connection is always the complete\n   * connection object because `addConnection()` is called only\n   * for the opened connections in the same runtime.\n   */\n  public async addConnection(client: WebSocketClientConnection): Promise<void> {\n    // Store this client in the map of clients created in this runtime.\n    // This way, the manager can distinguish between this runtime clients\n    // and extraneous runtime clients when synchronizing clients storage.\n    this.runtimeClients.set(client.id, client)\n\n    // Add the new client to the storage.\n    await this.addClient(client)\n\n    // Handle the incoming BroadcastChannel messages from other runtimes\n    // that attempt to control this runtime (via a remote connection wrapper).\n    // E.g. another runtime calling `client.send()` for the client in this runtime.\n    const handleExtraneousMessage = (\n      message: MessageEvent<WebSocketBroadcastChannelMessage>,\n    ) => {\n      const { type, payload } = message.data\n\n      // Ignore broadcasted messages for other clients.\n      if (\n        typeof payload === 'object' &&\n        'clientId' in payload &&\n        payload.clientId !== client.id\n      ) {\n        return\n      }\n\n      switch (type) {\n        case 'extraneous:send': {\n          client.send(payload.data)\n          break\n        }\n\n        case 'extraneous:close': {\n          client.close(payload.code, payload.reason)\n          break\n        }\n      }\n    }\n\n    const abortController = new AbortController()\n\n    this.channel.addEventListener('message', handleExtraneousMessage, {\n      signal: abortController.signal,\n    })\n\n    // Once closed, this connection cannot be operated on.\n    // This must include the extraneous runtimes as well.\n    client.addEventListener('close', () => abortController.abort(), {\n      once: true,\n    })\n  }\n}\n\n/**\n * A wrapper class to operate with WebSocket client connections\n * from other runtimes. This class maintains 1-1 public API\n * compatibility to the `WebSocketClientConnection` but relies\n * on the given `BroadcastChannel` to communicate instructions\n * with the client connections from other runtimes.\n */\nexport class WebSocketRemoteClientConnection\n  implements WebSocketClientConnectionProtocol\n{\n  constructor(\n    public readonly id: string,\n    public readonly url: URL,\n    private channel: BroadcastChannel,\n  ) {}\n\n  send(data: WebSocketData): void {\n    this.channel.postMessage({\n      type: 'extraneous:send',\n      payload: {\n        clientId: this.id,\n        data,\n      },\n    } as WebSocketBroadcastChannelMessage)\n  }\n\n  close(code?: number | undefined, reason?: string | undefined): void {\n    this.channel.postMessage({\n      type: 'extraneous:close',\n      payload: {\n        clientId: this.id,\n        code,\n        reason,\n      },\n    } as WebSocketBroadcastChannelMessage)\n  }\n}\n"],"mappings":"AAMA,SAASA,0BAAA,QAAkC;AAC3C,SAASC,6BAAA,QAAqC;AAuBvC,MAAMC,sBAAA,CAAuB;EAKlCC,YAAoBC,OAAA,EAA2B;IAA3B,KAAAA,OAAA,GAAAA,OAAA;IAGlB,KAAKC,KAAA,GACH,OAAOC,SAAA,KAAc,cACjB,IAAIL,6BAAA,CAA8B,IAClC,IAAID,0BAAA,CAA2B;IAErC,KAAKO,cAAA,GAAiB,mBAAIC,GAAA,CAAI;IAC9B,KAAKC,UAAA,GAAa,mBAAIC,GAAA,CAAI;IAE1B,KAAKN,OAAA,CAAQO,gBAAA,CAAiB,WAAYC,OAAA,IAAY;MACpD,IAAIA,OAAA,CAAQC,IAAA,EAAMC,IAAA,KAAS,aAAa;QACtC,KAAKC,qBAAA,CAAsB;MAC7B;IACF,CAAC;IAED,IAAI,OAAOC,MAAA,KAAW,aAAa;MACjCA,MAAA,CAAOL,gBAAA,CAAiB,WAAW,MAAOC,OAAA,IAAY;QACpD,IAAIA,OAAA,CAAQC,IAAA,EAAMC,IAAA,KAAS,mBAAmB;UAC5C,MAAM,KAAKG,oBAAA,CAAqB;QAClC;MACF,CAAC;IACH;EACF;EA5BQZ,KAAA;EACAE,cAAA;EACAE,UAAA;EA4BR,MAAcM,sBAAA,EAAwB;IACpC,MAAMG,aAAA,GAAgB,MAAM,KAAKb,KAAA,CAAMc,MAAA,CAAO;IAE9C,KAAKV,UAAA,GAAa,IAAIC,GAAA,CACpBQ,aAAA,CAAcE,GAAA,CAAKC,MAAA,IAAW;MAC5B,MAAMC,aAAA,GAAgB,KAAKf,cAAA,CAAegB,GAAA,CAAIF,MAAA,CAAOG,EAAE;MAMvD,IAAIF,aAAA,EAAe;QACjB,OAAOA,aAAA;MACT;MAEA,OAAO,IAAIG,+BAAA,CACTJ,MAAA,CAAOG,EAAA,EACP,IAAIE,GAAA,CAAIL,MAAA,CAAOM,GAAG,GAClB,KAAKvB,OACP;IACF,CAAC,CACH;EACF;EAEA,MAAca,qBAAA,EAAsC;IAClD,MAAM,KAAKZ,KAAA,CAAMuB,UAAA,CAAWC,KAAA,CAAMC,IAAA,CAAK,KAAKvB,cAAA,CAAewB,IAAA,CAAK,CAAC,CAAC;IAClE,KAAKxB,cAAA,CAAeyB,KAAA,CAAM;IAC1B,MAAM,KAAKjB,qBAAA,CAAsB;IACjC,KAAKkB,+BAAA,CAAgC;EACvC;EAAA;AAAA;AAAA;EAKA,IAAIC,QAAA,EAAkD;IACpD,OAAO,KAAKzB,UAAA;EACd;EAAA;AAAA;AAAA;AAAA;EAMQwB,gCAAA,EAAwC;IAC9C,KAAK7B,OAAA,CAAQ+B,WAAA,CAAY;MAAErB,IAAA,EAAM;IAAY,CAAC;EAChD;EAEA,MAAcsB,UAAUf,MAAA,EAAkD;IACxE,MAAM,KAAKhB,KAAA,CAAMgC,GAAA,CAAIhB,MAAM;IAG3B,MAAM,KAAKN,qBAAA,CAAsB;IACjC,KAAKkB,+BAAA,CAAgC;EACvC;EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAQA,MAAaK,cAAcjB,MAAA,EAAkD;IAI3E,KAAKd,cAAA,CAAegC,GAAA,CAAIlB,MAAA,CAAOG,EAAA,EAAIH,MAAM;IAGzC,MAAM,KAAKe,SAAA,CAAUf,MAAM;IAK3B,MAAMmB,uBAAA,GACJ5B,OAAA,IACG;MACH,MAAM;QAAEE,IAAA;QAAM2B;MAAQ,IAAI7B,OAAA,CAAQC,IAAA;MAGlC,IACE,OAAO4B,OAAA,KAAY,YACnB,cAAcA,OAAA,IACdA,OAAA,CAAQC,QAAA,KAAarB,MAAA,CAAOG,EAAA,EAC5B;QACA;MACF;MAEA,QAAQV,IAAA;QACN,KAAK;UAAmB;YACtBO,MAAA,CAAOsB,IAAA,CAAKF,OAAA,CAAQ5B,IAAI;YACxB;UACF;QAEA,KAAK;UAAoB;YACvBQ,MAAA,CAAOuB,KAAA,CAAMH,OAAA,CAAQI,IAAA,EAAMJ,OAAA,CAAQK,MAAM;YACzC;UACF;MACF;IACF;IAEA,MAAMC,eAAA,GAAkB,IAAIC,eAAA,CAAgB;IAE5C,KAAK5C,OAAA,CAAQO,gBAAA,CAAiB,WAAW6B,uBAAA,EAAyB;MAChES,MAAA,EAAQF,eAAA,CAAgBE;IAC1B,CAAC;IAID5B,MAAA,CAAOV,gBAAA,CAAiB,SAAS,MAAMoC,eAAA,CAAgBG,KAAA,CAAM,GAAG;MAC9DC,IAAA,EAAM;IACR,CAAC;EACH;AACF;AASO,MAAM1B,+BAAA,CAEb;EACEtB,YACkBqB,EAAA,EACAG,GAAA,EACRvB,OAAA,EACR;IAHgB,KAAAoB,EAAA,GAAAA,EAAA;IACA,KAAAG,GAAA,GAAAA,GAAA;IACR,KAAAvB,OAAA,GAAAA,OAAA;EACP;EAEHuC,KAAK9B,IAAA,EAA2B;IAC9B,KAAKT,OAAA,CAAQ+B,WAAA,CAAY;MACvBrB,IAAA,EAAM;MACN2B,OAAA,EAAS;QACPC,QAAA,EAAU,KAAKlB,EAAA;QACfX;MACF;IACF,CAAqC;EACvC;EAEA+B,MAAMC,IAAA,EAA2BC,MAAA,EAAmC;IAClE,KAAK1C,OAAA,CAAQ+B,WAAA,CAAY;MACvBrB,IAAA,EAAM;MACN2B,OAAA,EAAS;QACPC,QAAA,EAAU,KAAKlB,EAAA;QACfqB,IAAA;QACAC;MACF;IACF,CAAqC;EACvC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}