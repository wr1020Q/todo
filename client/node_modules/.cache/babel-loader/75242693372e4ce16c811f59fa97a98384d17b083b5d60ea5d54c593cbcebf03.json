{"ast":null,"code":"import { until } from \"@open-draft/until\";\nimport { executeHandlers } from './executeHandlers.mjs';\nimport { onUnhandledRequest } from './request/onUnhandledRequest.mjs';\nimport { storeResponseCookies } from './request/storeResponseCookies.mjs';\nasync function handleRequest(request, requestId, handlers, options, emitter, handleRequestOptions) {\n  emitter.emit(\"request:start\", {\n    request,\n    requestId\n  });\n  if (request.headers.get(\"accept\")?.includes(\"msw/passthrough\")) {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext\n    });\n  });\n  if (lookupResult.error) {\n    emitter.emit(\"unhandledException\", {\n      error: lookupResult.error,\n      request,\n      requestId\n    });\n    throw lookupResult.error;\n  }\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", {\n      request,\n      requestId\n    });\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  const {\n    response\n  } = lookupResult.data;\n  if (!response) {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  if (response.status === 302 && response.headers.get(\"x-msw-intention\") === \"passthrough\") {\n    emitter.emit(\"request:end\", {\n      request,\n      requestId\n    });\n    handleRequestOptions?.onPassthroughResponse?.(request);\n    return;\n  }\n  storeResponseCookies(request, response);\n  emitter.emit(\"request:match\", {\n    request,\n    requestId\n  });\n  const requiredLookupResult = lookupResult.data;\n  handleRequestOptions?.onMockedResponse?.(response, requiredLookupResult);\n  emitter.emit(\"request:end\", {\n    request,\n    requestId\n  });\n  return response;\n}\nexport { handleRequest };","map":{"version":3,"names":["until","executeHandlers","onUnhandledRequest","storeResponseCookies","handleRequest","request","requestId","handlers","options","emitter","handleRequestOptions","emit","headers","get","includes","onPassthroughResponse","lookupResult","resolutionContext","error","data","response","status","requiredLookupResult","onMockedResponse"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\msw\\src\\core\\utils\\handleRequest.ts"],"sourcesContent":["import { until } from '@open-draft/until'\nimport { Emitter } from 'strict-event-emitter'\nimport { LifeCycleEventsMap, SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport type { RequestHandler } from '../handlers/RequestHandler'\nimport { HandlersExecutionResult, executeHandlers } from './executeHandlers'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { storeResponseCookies } from './request/storeResponseCookies'\n\nexport interface HandleRequestOptions {\n  /**\n   * `resolutionContext` is not part of the general public api\n   * but is exposed to aid in creating extensions like\n   * `@mswjs/http-middleware`.\n   */\n  resolutionContext?: {\n    /**\n     * A base url to use when resolving relative urls.\n     * @note This is primarily used by the `@mswjs/http-middleware`\n     * to resolve relative urls in the context of the running server\n     */\n    baseUrl?: string\n  }\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: Request): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: Response,\n    handler: RequiredDeep<HandlersExecutionResult>,\n  ): void\n}\n\nexport async function handleRequest(\n  request: Request,\n  requestId: string,\n  handlers: Array<RequestHandler>,\n  options: RequiredDeep<SharedOptions>,\n  emitter: Emitter<LifeCycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions,\n): Promise<Response | undefined> {\n  emitter.emit('request:start', { request, requestId })\n\n  // Perform requests wrapped in \"bypass()\" as-is.\n  if (request.headers.get('accept')?.includes('msw/passthrough')) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const lookupResult = await until(() => {\n    return executeHandlers({\n      request,\n      requestId,\n      handlers,\n      resolutionContext: handleRequestOptions?.resolutionContext,\n    })\n  })\n\n  if (lookupResult.error) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', {\n      error: lookupResult.error,\n      request,\n      requestId,\n    })\n    throw lookupResult.error\n  }\n\n  // If the handler lookup returned nothing, no request handler was found\n  // matching this request. Report the request as unhandled.\n  if (!lookupResult.data) {\n    await onUnhandledRequest(request, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', { request, requestId })\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  const { response } = lookupResult.data\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Perform the request as-is when the developer explicitly returned \"req.passthrough()\".\n  // This produces no warning as the request was handled.\n  if (\n    response.status === 302 &&\n    response.headers.get('x-msw-intention') === 'passthrough'\n  ) {\n    emitter.emit('request:end', { request, requestId })\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the cookie jar.\n  storeResponseCookies(request, response)\n\n  emitter.emit('request:match', { request, requestId })\n\n  const requiredLookupResult =\n    lookupResult.data as RequiredDeep<HandlersExecutionResult>\n\n  handleRequestOptions?.onMockedResponse?.(response, requiredLookupResult)\n\n  emitter.emit('request:end', { request, requestId })\n\n  return response\n}\n"],"mappings":"AAAA,SAASA,KAAA,QAAa;AAKtB,SAAkCC,eAAA,QAAuB;AACzD,SAASC,kBAAA,QAA0B;AACnC,SAASC,oBAAA,QAA4B;AA+BrC,eAAsBC,cACpBC,OAAA,EACAC,SAAA,EACAC,QAAA,EACAC,OAAA,EACAC,OAAA,EACAC,oBAAA,EAC+B;EAC/BD,OAAA,CAAQE,IAAA,CAAK,iBAAiB;IAAEN,OAAA;IAASC;EAAU,CAAC;EAGpD,IAAID,OAAA,CAAQO,OAAA,CAAQC,GAAA,CAAI,QAAQ,GAAGC,QAAA,CAAS,iBAAiB,GAAG;IAC9DL,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBK,qBAAA,GAAwBV,OAAO;IACrD;EACF;EAGA,MAAMW,YAAA,GAAe,MAAMhB,KAAA,CAAM,MAAM;IACrC,OAAOC,eAAA,CAAgB;MACrBI,OAAA;MACAC,SAAA;MACAC,QAAA;MACAU,iBAAA,EAAmBP,oBAAA,EAAsBO;IAC3C,CAAC;EACH,CAAC;EAED,IAAID,YAAA,CAAaE,KAAA,EAAO;IAEtBT,OAAA,CAAQE,IAAA,CAAK,sBAAsB;MACjCO,KAAA,EAAOF,YAAA,CAAaE,KAAA;MACpBb,OAAA;MACAC;IACF,CAAC;IACD,MAAMU,YAAA,CAAaE,KAAA;EACrB;EAIA,IAAI,CAACF,YAAA,CAAaG,IAAA,EAAM;IACtB,MAAMjB,kBAAA,CAAmBG,OAAA,EAASG,OAAA,CAAQN,kBAAkB;IAC5DO,OAAA,CAAQE,IAAA,CAAK,qBAAqB;MAAEN,OAAA;MAASC;IAAU,CAAC;IACxDG,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBK,qBAAA,GAAwBV,OAAO;IACrD;EACF;EAEA,MAAM;IAAEe;EAAS,IAAIJ,YAAA,CAAaG,IAAA;EAIlC,IAAI,CAACC,QAAA,EAAU;IACbX,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBK,qBAAA,GAAwBV,OAAO;IACrD;EACF;EAIA,IACEe,QAAA,CAASC,MAAA,KAAW,OACpBD,QAAA,CAASR,OAAA,CAAQC,GAAA,CAAI,iBAAiB,MAAM,eAC5C;IACAJ,OAAA,CAAQE,IAAA,CAAK,eAAe;MAAEN,OAAA;MAASC;IAAU,CAAC;IAClDI,oBAAA,EAAsBK,qBAAA,GAAwBV,OAAO;IACrD;EACF;EAGAF,oBAAA,CAAqBE,OAAA,EAASe,QAAQ;EAEtCX,OAAA,CAAQE,IAAA,CAAK,iBAAiB;IAAEN,OAAA;IAASC;EAAU,CAAC;EAEpD,MAAMgB,oBAAA,GACJN,YAAA,CAAaG,IAAA;EAEfT,oBAAA,EAAsBa,gBAAA,GAAmBH,QAAA,EAAUE,oBAAoB;EAEvEb,OAAA,CAAQE,IAAA,CAAK,eAAe;IAAEN,OAAA;IAASC;EAAU,CAAC;EAElD,OAAOc,QAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}