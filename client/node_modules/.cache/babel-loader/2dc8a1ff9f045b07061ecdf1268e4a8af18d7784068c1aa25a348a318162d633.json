{"ast":null,"code":"import { kDispatchEvent } from '../handlers/WebSocketHandler.mjs';\nimport { webSocketInterceptor } from './webSocketInterceptor.mjs';\nimport { onUnhandledRequest } from '../utils/request/onUnhandledRequest.mjs';\nimport { isHandlerKind } from '../utils/internal/isHandlerKind.mjs';\nfunction handleWebSocketEvent(options) {\n  webSocketInterceptor.on(\"connection\", async connection => {\n    const handlers = options.getHandlers();\n    const connectionEvent = new MessageEvent(\"connection\", {\n      data: connection\n    });\n    const matchingHandlers = [];\n    for (const handler of handlers) {\n      if (isHandlerKind(\"EventHandler\")(handler) && handler.predicate({\n        event: connectionEvent,\n        parsedResult: handler.parse({\n          event: connectionEvent\n        })\n      })) {\n        matchingHandlers.push(handler);\n      }\n    }\n    if (matchingHandlers.length > 0) {\n      options?.onMockedConnection(connection);\n      for (const handler of matchingHandlers) {\n        handler[kDispatchEvent](connectionEvent);\n      }\n    } else {\n      const request = new Request(connection.client.url, {\n        headers: {\n          upgrade: \"websocket\",\n          connection: \"upgrade\"\n        }\n      });\n      await onUnhandledRequest(request, options.getUnhandledRequestStrategy()).catch(error => {\n        const errorEvent = new Event(\"error\");\n        Object.defineProperty(errorEvent, \"cause\", {\n          enumerable: true,\n          configurable: false,\n          value: error\n        });\n        connection.client.socket.dispatchEvent(errorEvent);\n      });\n      options?.onPassthroughConnection(connection);\n      connection.server.connect();\n    }\n  });\n}\nexport { handleWebSocketEvent };","map":{"version":3,"names":["kDispatchEvent","webSocketInterceptor","onUnhandledRequest","isHandlerKind","handleWebSocketEvent","options","on","connection","handlers","getHandlers","connectionEvent","MessageEvent","data","matchingHandlers","handler","predicate","event","parsedResult","parse","push","length","onMockedConnection","request","Request","client","url","headers","upgrade","getUnhandledRequestStrategy","catch","error","errorEvent","Event","Object","defineProperty","enumerable","configurable","value","socket","dispatchEvent","onPassthroughConnection","server","connect"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\msw\\src\\core\\ws\\handleWebSocketEvent.ts"],"sourcesContent":["import type { WebSocketConnectionData } from '@mswjs/interceptors/lib/browser/interceptors/WebSocket'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { WebSocketHandler, kDispatchEvent } from '../handlers/WebSocketHandler'\nimport { webSocketInterceptor } from './webSocketInterceptor'\nimport {\n  onUnhandledRequest,\n  UnhandledRequestStrategy,\n} from '../utils/request/onUnhandledRequest'\nimport { isHandlerKind } from '../utils/internal/isHandlerKind'\n\ninterface HandleWebSocketEventOptions {\n  getUnhandledRequestStrategy: () => UnhandledRequestStrategy\n  getHandlers: () => Array<RequestHandler | WebSocketHandler>\n  onMockedConnection: (connection: WebSocketConnectionData) => void\n  onPassthroughConnection: (onnection: WebSocketConnectionData) => void\n}\n\nexport function handleWebSocketEvent(options: HandleWebSocketEventOptions) {\n  webSocketInterceptor.on('connection', async (connection) => {\n    const handlers = options.getHandlers()\n\n    const connectionEvent = new MessageEvent('connection', {\n      data: connection,\n    })\n\n    // First, filter only those WebSocket handlers that\n    // match the \"ws.link()\" endpoint predicate. Don't dispatch\n    // anything yet so the logger can be attached to the connection\n    // before it potentially sends events.\n    const matchingHandlers: Array<WebSocketHandler> = []\n\n    for (const handler of handlers) {\n      if (\n        isHandlerKind('EventHandler')(handler) &&\n        handler.predicate({\n          event: connectionEvent,\n          parsedResult: handler.parse({\n            event: connectionEvent,\n          }),\n        })\n      ) {\n        matchingHandlers.push(handler)\n      }\n    }\n\n    if (matchingHandlers.length > 0) {\n      options?.onMockedConnection(connection)\n\n      // Iterate over the handlers and forward the connection\n      // event to WebSocket event handlers. This is equivalent\n      // to dispatching that event onto multiple listeners.\n      for (const handler of matchingHandlers) {\n        handler[kDispatchEvent](connectionEvent)\n      }\n    } else {\n      // Construct a request representing this WebSocket connection.\n      const request = new Request(connection.client.url, {\n        headers: {\n          upgrade: 'websocket',\n          connection: 'upgrade',\n        },\n      })\n      await onUnhandledRequest(\n        request,\n        options.getUnhandledRequestStrategy(),\n      ).catch((error) => {\n        const errorEvent = new Event('error')\n        Object.defineProperty(errorEvent, 'cause', {\n          enumerable: true,\n          configurable: false,\n          value: error,\n        })\n        connection.client.socket.dispatchEvent(errorEvent)\n      })\n\n      options?.onPassthroughConnection(connection)\n\n      // If none of the \"ws\" handlers matched,\n      // establish the WebSocket connection as-is.\n      connection.server.connect()\n    }\n  })\n}\n"],"mappings":"AAEA,SAA2BA,cAAA,QAAsB;AACjD,SAASC,oBAAA,QAA4B;AACrC,SACEC,kBAAA,QAEK;AACP,SAASC,aAAA,QAAqB;AASvB,SAASC,qBAAqBC,OAAA,EAAsC;EACzEJ,oBAAA,CAAqBK,EAAA,CAAG,cAAc,MAAOC,UAAA,IAAe;IAC1D,MAAMC,QAAA,GAAWH,OAAA,CAAQI,WAAA,CAAY;IAErC,MAAMC,eAAA,GAAkB,IAAIC,YAAA,CAAa,cAAc;MACrDC,IAAA,EAAML;IACR,CAAC;IAMD,MAAMM,gBAAA,GAA4C,EAAC;IAEnD,WAAWC,OAAA,IAAWN,QAAA,EAAU;MAC9B,IACEL,aAAA,CAAc,cAAc,EAAEW,OAAO,KACrCA,OAAA,CAAQC,SAAA,CAAU;QAChBC,KAAA,EAAON,eAAA;QACPO,YAAA,EAAcH,OAAA,CAAQI,KAAA,CAAM;UAC1BF,KAAA,EAAON;QACT,CAAC;MACH,CAAC,GACD;QACAG,gBAAA,CAAiBM,IAAA,CAAKL,OAAO;MAC/B;IACF;IAEA,IAAID,gBAAA,CAAiBO,MAAA,GAAS,GAAG;MAC/Bf,OAAA,EAASgB,kBAAA,CAAmBd,UAAU;MAKtC,WAAWO,OAAA,IAAWD,gBAAA,EAAkB;QACtCC,OAAA,CAAQd,cAAc,EAAEU,eAAe;MACzC;IACF,OAAO;MAEL,MAAMY,OAAA,GAAU,IAAIC,OAAA,CAAQhB,UAAA,CAAWiB,MAAA,CAAOC,GAAA,EAAK;QACjDC,OAAA,EAAS;UACPC,OAAA,EAAS;UACTpB,UAAA,EAAY;QACd;MACF,CAAC;MACD,MAAML,kBAAA,CACJoB,OAAA,EACAjB,OAAA,CAAQuB,2BAAA,CAA4B,CACtC,EAAEC,KAAA,CAAOC,KAAA,IAAU;QACjB,MAAMC,UAAA,GAAa,IAAIC,KAAA,CAAM,OAAO;QACpCC,MAAA,CAAOC,cAAA,CAAeH,UAAA,EAAY,SAAS;UACzCI,UAAA,EAAY;UACZC,YAAA,EAAc;UACdC,KAAA,EAAOP;QACT,CAAC;QACDvB,UAAA,CAAWiB,MAAA,CAAOc,MAAA,CAAOC,aAAA,CAAcR,UAAU;MACnD,CAAC;MAED1B,OAAA,EAASmC,uBAAA,CAAwBjC,UAAU;MAI3CA,UAAA,CAAWkC,MAAA,CAAOC,OAAA,CAAQ;IAC5B;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}