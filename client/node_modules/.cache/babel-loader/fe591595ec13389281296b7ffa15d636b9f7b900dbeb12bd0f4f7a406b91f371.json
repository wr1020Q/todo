{"ast":null,"code":"// src/format.ts\nvar POSITIONALS_EXP = /(%?)(%([sdijo]))/g;\nfunction serializePositional(positional, flag) {\n  switch (flag) {\n    case \"s\":\n      return positional;\n    case \"d\":\n    case \"i\":\n      return Number(positional);\n    case \"j\":\n      return JSON.stringify(positional);\n    case \"o\":\n      {\n        if (typeof positional === \"string\") {\n          return positional;\n        }\n        const json = JSON.stringify(positional);\n        if (json === \"{}\" || json === \"[]\" || /^\\[object .+?\\]$/.test(json)) {\n          return positional;\n        }\n        return json;\n      }\n  }\n}\nfunction format(message) {\n  for (var _len = arguments.length, positionals = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    positionals[_key - 1] = arguments[_key];\n  }\n  if (positionals.length === 0) {\n    return message;\n  }\n  let positionalIndex = 0;\n  let formattedMessage = message.replace(POSITIONALS_EXP, (match, isEscaped, _, flag) => {\n    const positional = positionals[positionalIndex];\n    const value = serializePositional(positional, flag);\n    if (!isEscaped) {\n      positionalIndex++;\n      return value;\n    }\n    return match;\n  });\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(\" \")}`;\n  }\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, \"%\");\n  return formattedMessage;\n}\n\n// src/invariant.ts\nvar STACK_FRAMES_TO_IGNORE = 2;\nfunction cleanErrorStack(error) {\n  if (!error.stack) {\n    return;\n  }\n  const nextStack = error.stack.split(\"\\n\");\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE);\n  error.stack = nextStack.join(\"\\n\");\n}\nvar InvariantError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = \"Invariant Violation\";\n    for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      positionals[_key2 - 1] = arguments[_key2];\n    }\n    this.message = format(message, ...positionals);\n    cleanErrorStack(this);\n  }\n};\nvar invariant = function (predicate, message) {\n  if (!predicate) {\n    for (var _len3 = arguments.length, positionals = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      positionals[_key3 - 2] = arguments[_key3];\n    }\n    throw new InvariantError(message, ...positionals);\n  }\n};\ninvariant.as = function (ErrorConstructor, predicate, message) {\n  if (!predicate) {\n    for (var _len4 = arguments.length, positionals = new Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n      positionals[_key4 - 3] = arguments[_key4];\n    }\n    const formatMessage = positionals.length === 0 ? message : format(message, ...positionals);\n    let error;\n    try {\n      error = Reflect.construct(ErrorConstructor, [formatMessage]);\n    } catch (err) {\n      error = ErrorConstructor(formatMessage);\n    }\n    throw error;\n  }\n};\nexport { InvariantError, format, invariant };","map":{"version":3,"names":["POSITIONALS_EXP","serializePositional","positional","flag","Number","JSON","stringify","json","test","format","message","_len","arguments","length","positionals","Array","_key","positionalIndex","formattedMessage","replace","match","isEscaped","_","value","slice","join","STACK_FRAMES_TO_IGNORE","cleanErrorStack","error","stack","nextStack","split","splice","InvariantError","Error","constructor","name","_len2","_key2","invariant","predicate","_len3","_key3","as","ErrorConstructor","_len4","_key4","formatMessage","Reflect","construct","err"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\outvariant\\src\\format.ts","C:\\Users\\hinan\\todo-app\\client\\node_modules\\outvariant\\src\\invariant.ts"],"sourcesContent":["const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n","import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage =\n      positionals.length === 0 ? message : format(message, ...positionals)\n    let error: Error\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [\n        formatMessage,\n      ])\n    } catch (err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage)\n    }\n\n    throw error\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}