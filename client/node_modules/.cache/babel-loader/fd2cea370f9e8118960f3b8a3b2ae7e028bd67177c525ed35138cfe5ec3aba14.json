{"ast":null,"code":"import { Emitter } from \"strict-event-emitter\";\nimport { createRequestId } from \"@mswjs/interceptors\";\nimport { matchRequestUrl } from '../utils/matching/matchRequestUrl.mjs';\nimport { getCallFrame } from '../utils/internal/getCallFrame.mjs';\nconst kEmitter = Symbol(\"kEmitter\");\nconst kDispatchEvent = Symbol(\"kDispatchEvent\");\nconst kSender = Symbol(\"kSender\");\nconst kStopPropagationPatched = Symbol(\"kStopPropagationPatched\");\nconst KOnStopPropagation = Symbol(\"KOnStopPropagation\");\nclass WebSocketHandler {\n  constructor(url) {\n    this.url = url;\n    this.id = createRequestId();\n    this[kEmitter] = new Emitter();\n    this.callFrame = getCallFrame(new Error());\n    this.__kind = \"EventHandler\";\n  }\n  __kind;\n  id;\n  callFrame;\n  [kEmitter];\n  parse(args) {\n    const {\n      data: connection\n    } = args.event;\n    const {\n      url: clientUrl\n    } = connection.client;\n    clientUrl.pathname = clientUrl.pathname.replace(/^\\/socket.io\\//, \"/\");\n    const match = matchRequestUrl(clientUrl, this.url);\n    return {\n      match\n    };\n  }\n  predicate(args) {\n    return args.parsedResult.match.matches;\n  }\n  async [kDispatchEvent](event) {\n    const parsedResult = this.parse({\n      event\n    });\n    const connection = event.data;\n    const resolvedConnection = {\n      ...connection,\n      params: parsedResult.match.params || {}\n    };\n    connection.client.addEventListener(\"message\", createStopPropagationListener(this));\n    connection.client.addEventListener(\"close\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"open\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"message\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"error\", createStopPropagationListener(this));\n    connection.server.addEventListener(\"close\", createStopPropagationListener(this));\n    this[kEmitter].emit(\"connection\", resolvedConnection);\n  }\n}\nfunction createStopPropagationListener(handler) {\n  return function stopPropagationListener(event) {\n    const propagationStoppedAt = Reflect.get(event, \"kPropagationStoppedAt\");\n    if (propagationStoppedAt && handler.id !== propagationStoppedAt) {\n      event.stopImmediatePropagation();\n      return;\n    }\n    Object.defineProperty(event, KOnStopPropagation, {\n      value() {\n        Object.defineProperty(event, \"kPropagationStoppedAt\", {\n          value: handler.id\n        });\n      },\n      configurable: true\n    });\n    if (!Reflect.get(event, kStopPropagationPatched)) {\n      event.stopPropagation = new Proxy(event.stopPropagation, {\n        apply: (target, thisArg, args) => {\n          Reflect.get(event, KOnStopPropagation)?.call(handler);\n          return Reflect.apply(target, thisArg, args);\n        }\n      });\n      Object.defineProperty(event, kStopPropagationPatched, {\n        value: true,\n        // If something else attempts to redefine this, throw.\n        configurable: false\n      });\n    }\n  };\n}\nexport { WebSocketHandler, kDispatchEvent, kEmitter, kSender };","map":{"version":3,"names":["Emitter","createRequestId","matchRequestUrl","getCallFrame","kEmitter","Symbol","kDispatchEvent","kSender","kStopPropagationPatched","KOnStopPropagation","WebSocketHandler","constructor","url","id","callFrame","Error","__kind","parse","args","data","connection","event","clientUrl","client","pathname","replace","match","predicate","parsedResult","matches","resolvedConnection","params","addEventListener","createStopPropagationListener","server","emit","handler","stopPropagationListener","propagationStoppedAt","Reflect","get","stopImmediatePropagation","Object","defineProperty","value","configurable","stopPropagation","Proxy","apply","target","thisArg","call"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\msw\\src\\core\\handlers\\WebSocketHandler.ts"],"sourcesContent":["import { Emitter } from 'strict-event-emitter'\nimport { createRequestId } from '@mswjs/interceptors'\nimport type { WebSocketConnectionData } from '@mswjs/interceptors/WebSocket'\nimport {\n  type Match,\n  type Path,\n  type PathParams,\n  matchRequestUrl,\n} from '../utils/matching/matchRequestUrl'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport type { HandlerKind } from './common'\n\ntype WebSocketHandlerParsedResult = {\n  match: Match\n}\n\nexport type WebSocketHandlerEventMap = {\n  connection: [args: WebSocketHandlerConnection]\n}\n\nexport interface WebSocketHandlerConnection extends WebSocketConnectionData {\n  params: PathParams\n}\n\nexport const kEmitter = Symbol('kEmitter')\nexport const kDispatchEvent = Symbol('kDispatchEvent')\nexport const kSender = Symbol('kSender')\nconst kStopPropagationPatched = Symbol('kStopPropagationPatched')\nconst KOnStopPropagation = Symbol('KOnStopPropagation')\n\nexport class WebSocketHandler {\n  private readonly __kind: HandlerKind\n\n  public id: string\n  public callFrame?: string\n\n  protected [kEmitter]: Emitter<WebSocketHandlerEventMap>\n\n  constructor(private readonly url: Path) {\n    this.id = createRequestId()\n\n    this[kEmitter] = new Emitter()\n    this.callFrame = getCallFrame(new Error())\n    this.__kind = 'EventHandler'\n  }\n\n  public parse(args: {\n    event: MessageEvent<WebSocketConnectionData>\n  }): WebSocketHandlerParsedResult {\n    const { data: connection } = args.event\n    const { url: clientUrl } = connection.client\n\n    /**\n     * @note Remove the Socket.IO path prefix from the WebSocket\n     * client URL. This is an exception to keep the users from\n     * including the implementation details in their handlers.\n     */\n    clientUrl.pathname = clientUrl.pathname.replace(/^\\/socket.io\\//, '/')\n\n    const match = matchRequestUrl(clientUrl, this.url)\n\n    return {\n      match,\n    }\n  }\n\n  public predicate(args: {\n    event: MessageEvent<WebSocketConnectionData>\n    parsedResult: WebSocketHandlerParsedResult\n  }): boolean {\n    return args.parsedResult.match.matches\n  }\n\n  async [kDispatchEvent](\n    event: MessageEvent<WebSocketConnectionData>,\n  ): Promise<void> {\n    const parsedResult = this.parse({ event })\n    const connection = event.data\n\n    const resolvedConnection: WebSocketHandlerConnection = {\n      ...connection,\n      params: parsedResult.match.params || {},\n    }\n\n    // Support `event.stopPropagation()` for various client/server events.\n    connection.client.addEventListener(\n      'message',\n      createStopPropagationListener(this),\n    )\n    connection.client.addEventListener(\n      'close',\n      createStopPropagationListener(this),\n    )\n\n    connection.server.addEventListener(\n      'open',\n      createStopPropagationListener(this),\n    )\n    connection.server.addEventListener(\n      'message',\n      createStopPropagationListener(this),\n    )\n    connection.server.addEventListener(\n      'error',\n      createStopPropagationListener(this),\n    )\n    connection.server.addEventListener(\n      'close',\n      createStopPropagationListener(this),\n    )\n\n    // Emit the connection event on the handler.\n    // This is what the developer adds listeners for.\n    this[kEmitter].emit('connection', resolvedConnection)\n  }\n}\n\nfunction createStopPropagationListener(handler: WebSocketHandler) {\n  return function stopPropagationListener(event: Event) {\n    const propagationStoppedAt = Reflect.get(event, 'kPropagationStoppedAt') as\n      | string\n      | undefined\n\n    if (propagationStoppedAt && handler.id !== propagationStoppedAt) {\n      event.stopImmediatePropagation()\n      return\n    }\n\n    Object.defineProperty(event, KOnStopPropagation, {\n      value(this: WebSocketHandler) {\n        Object.defineProperty(event, 'kPropagationStoppedAt', {\n          value: handler.id,\n        })\n      },\n      configurable: true,\n    })\n\n    // Since the same event instance is shared between all client/server objects,\n    // make sure to patch its `stopPropagation` method only once.\n    if (!Reflect.get(event, kStopPropagationPatched)) {\n      event.stopPropagation = new Proxy(event.stopPropagation, {\n        apply: (target, thisArg, args) => {\n          Reflect.get(event, KOnStopPropagation)?.call(handler)\n          return Reflect.apply(target, thisArg, args)\n        },\n      })\n\n      Object.defineProperty(event, kStopPropagationPatched, {\n        value: true,\n        // If something else attempts to redefine this, throw.\n        configurable: false,\n      })\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}