{"ast":null,"code":"const executeHandlers = async ({\n  request,\n  requestId,\n  handlers,\n  resolutionContext\n}) => {\n  let matchingHandler = null;\n  let result = null;\n  for (const handler of handlers) {\n    result = await handler.run({\n      request,\n      requestId,\n      resolutionContext\n    });\n    if (result !== null) {\n      matchingHandler = handler;\n    }\n    if (result?.response) {\n      break;\n    }\n  }\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response\n    };\n  }\n  return null;\n};\nexport { executeHandlers };","map":{"version":3,"names":["executeHandlers","request","requestId","handlers","resolutionContext","matchingHandler","result","handler","run","response","parsedResult"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\msw\\src\\core\\utils\\executeHandlers.ts"],"sourcesContent":["import {\n  RequestHandler,\n  type RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\n\nexport interface HandlersExecutionResult {\n  handler: RequestHandler\n  parsedResult?: any\n  response?: Response\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Executes the list of request handlers against the given request.\n * Returns the execution result object containing any matching request\n * handler and any mocked response it returned.\n */\nexport const executeHandlers = async <Handlers extends Array<RequestHandler>>({\n  request,\n  requestId,\n  handlers,\n  resolutionContext,\n}: {\n  request: Request\n  requestId: string\n  handlers: Handlers\n  resolutionContext?: ResponseResolutionContext\n}): Promise<HandlersExecutionResult | null> => {\n  let matchingHandler: RequestHandler | null = null\n  let result: RequestHandlerExecutionResult<any> | null = null\n\n  for (const handler of handlers) {\n    result = await handler.run({ request, requestId, resolutionContext })\n\n    // If the handler produces some result for this request,\n    // it automatically becomes matching.\n    if (result !== null) {\n      matchingHandler = handler\n    }\n\n    // Stop the lookup if this handler returns a mocked response.\n    // If it doesn't, it will still be considered the last matching\n    // handler until any of them returns a response. This way we can\n    // distinguish between fallthrough handlers without responses\n    // and the lack of a matching handler.\n    if (result?.response) {\n      break\n    }\n  }\n\n  if (matchingHandler) {\n    return {\n      handler: matchingHandler,\n      parsedResult: result?.parsedResult,\n      response: result?.response,\n    }\n  }\n\n  return null\n}\n"],"mappings":"AAoBO,MAAMA,eAAA,GAAkB,MAAAA,CAA+C;EAC5EC,OAAA;EACAC,SAAA;EACAC,QAAA;EACAC;AACF,MAK+C;EAC7C,IAAIC,eAAA,GAAyC;EAC7C,IAAIC,MAAA,GAAoD;EAExD,WAAWC,OAAA,IAAWJ,QAAA,EAAU;IAC9BG,MAAA,GAAS,MAAMC,OAAA,CAAQC,GAAA,CAAI;MAAEP,OAAA;MAASC,SAAA;MAAWE;IAAkB,CAAC;IAIpE,IAAIE,MAAA,KAAW,MAAM;MACnBD,eAAA,GAAkBE,OAAA;IACpB;IAOA,IAAID,MAAA,EAAQG,QAAA,EAAU;MACpB;IACF;EACF;EAEA,IAAIJ,eAAA,EAAiB;IACnB,OAAO;MACLE,OAAA,EAASF,eAAA;MACTK,YAAA,EAAcJ,MAAA,EAAQI,YAAA;MACtBD,QAAA,EAAUH,MAAA,EAAQG;IACpB;EACF;EAEA,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}