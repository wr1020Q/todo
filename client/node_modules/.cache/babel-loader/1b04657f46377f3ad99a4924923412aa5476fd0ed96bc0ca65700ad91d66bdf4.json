{"ast":null,"code":"import { invariant } from \"outvariant\";\nimport { WebSocketHandler, kEmitter } from './handlers/WebSocketHandler.mjs';\nimport { isPath } from './utils/matching/matchRequestUrl.mjs';\nimport { WebSocketClientManager } from './ws/WebSocketClientManager.mjs';\nfunction isBroadcastChannelWithUnref(channel) {\n  return typeof Reflect.get(channel, \"unref\") !== \"undefined\";\n}\nconst webSocketChannel = new BroadcastChannel(\"msw:websocket-client-manager\");\nif (isBroadcastChannelWithUnref(webSocketChannel)) {\n  webSocketChannel.unref();\n}\nfunction createWebSocketLinkHandler(url) {\n  invariant(url, \"Expected a WebSocket server URL but got undefined\");\n  invariant(isPath(url), \"Expected a WebSocket server URL to be a valid path but got %s\", typeof url);\n  const clientManager = new WebSocketClientManager(webSocketChannel);\n  return {\n    get clients() {\n      return clientManager.clients;\n    },\n    addEventListener(event, listener) {\n      const handler = new WebSocketHandler(url);\n      handler[kEmitter].on(\"connection\", async _ref => {\n        let {\n          client\n        } = _ref;\n        await clientManager.addConnection(client);\n      });\n      handler[kEmitter].on(event, listener);\n      return handler;\n    },\n    broadcast(data) {\n      this.broadcastExcept([], data);\n    },\n    broadcastExcept(clients, data) {\n      const ignoreClients = Array.prototype.concat(clients).map(client => client.id);\n      clientManager.clients.forEach(otherClient => {\n        if (!ignoreClients.includes(otherClient.id)) {\n          otherClient.send(data);\n        }\n      });\n    }\n  };\n}\nconst ws = {\n  link: createWebSocketLinkHandler\n};\nexport { ws };","map":{"version":3,"names":["invariant","WebSocketHandler","kEmitter","isPath","WebSocketClientManager","isBroadcastChannelWithUnref","channel","Reflect","get","webSocketChannel","BroadcastChannel","unref","createWebSocketLinkHandler","url","clientManager","clients","addEventListener","event","listener","handler","on","_ref","client","addConnection","broadcast","data","broadcastExcept","ignoreClients","Array","prototype","concat","map","id","forEach","otherClient","includes","send","ws","link"],"sources":["C:\\Users\\hinan\\todo-app\\client\\node_modules\\msw\\src\\core\\ws.ts"],"sourcesContent":["import { invariant } from 'outvariant'\nimport type {\n  WebSocketData,\n  WebSocketClientConnectionProtocol,\n} from '@mswjs/interceptors/WebSocket'\nimport {\n  WebSocketHandler,\n  kEmitter,\n  type WebSocketHandlerEventMap,\n} from './handlers/WebSocketHandler'\nimport { Path, isPath } from './utils/matching/matchRequestUrl'\nimport { WebSocketClientManager } from './ws/WebSocketClientManager'\n\nfunction isBroadcastChannelWithUnref(\n  channel: BroadcastChannel,\n): channel is BroadcastChannel & NodeJS.RefCounted {\n  return typeof Reflect.get(channel, 'unref') !== 'undefined'\n}\n\nconst webSocketChannel = new BroadcastChannel('msw:websocket-client-manager')\n\nif (isBroadcastChannelWithUnref(webSocketChannel)) {\n  // Allows the Node.js thread to exit if it is the only active handle in the event system.\n  // https://nodejs.org/api/worker_threads.html#broadcastchannelunref\n  webSocketChannel.unref()\n}\n\nexport type WebSocketEventListener<\n  EventType extends keyof WebSocketHandlerEventMap,\n> = (...args: WebSocketHandlerEventMap[EventType]) => void\n\nexport type WebSocketLink = {\n  /**\n   * A set of all WebSocket clients connected\n   * to this link.\n   *\n   * @see {@link https://mswjs.io/docs/api/ws#clients `clients` API reference}\n   */\n  clients: Set<WebSocketClientConnectionProtocol>\n\n  /**\n   * Adds an event listener to this WebSocket link.\n   *\n   * @example\n   * const chat = ws.link('wss://chat.example.com')\n   * chat.addEventListener('connection', listener)\n   *\n   * @see {@link https://mswjs.io/docs/api/ws#onevent-listener `on()` API reference}\n   */\n  addEventListener<EventType extends keyof WebSocketHandlerEventMap>(\n    event: EventType,\n    listener: WebSocketEventListener<EventType>,\n  ): WebSocketHandler\n\n  /**\n   * Broadcasts the given data to all WebSocket clients.\n   *\n   * @example\n   * const service = ws.link('wss://example.com')\n   * service.addEventListener('connection', () => {\n   *   service.broadcast('hello, everyone!')\n   * })\n   *\n   * @see {@link https://mswjs.io/docs/api/ws#broadcastdata `broadcast()` API reference}\n   */\n  broadcast(data: WebSocketData): void\n\n  /**\n   * Broadcasts the given data to all WebSocket clients\n   * except the ones provided in the `clients` argument.\n   *\n   * @example\n   * const service = ws.link('wss://example.com')\n   * service.addEventListener('connection', ({ client }) => {\n   *   service.broadcastExcept(client, 'hi, the rest of you!')\n   * })\n   *\n   * @see {@link https://mswjs.io/docs/api/ws#broadcastexceptclients-data `broadcast()` API reference}\n   */\n  broadcastExcept(\n    clients:\n      | WebSocketClientConnectionProtocol\n      | Array<WebSocketClientConnectionProtocol>,\n    data: WebSocketData,\n  ): void\n}\n\n/**\n * Intercepts outgoing WebSocket connections to the given URL.\n *\n * @example\n * const chat = ws.link('wss://chat.example.com')\n * chat.addEventListener('connection', ({ client }) => {\n *   client.send('hello from server!')\n * })\n */\nfunction createWebSocketLinkHandler(url: Path): WebSocketLink {\n  invariant(url, 'Expected a WebSocket server URL but got undefined')\n\n  invariant(\n    isPath(url),\n    'Expected a WebSocket server URL to be a valid path but got %s',\n    typeof url,\n  )\n\n  const clientManager = new WebSocketClientManager(webSocketChannel)\n\n  return {\n    get clients() {\n      return clientManager.clients\n    },\n    addEventListener(event, listener) {\n      const handler = new WebSocketHandler(url)\n\n      // Add the connection event listener for when the\n      // handler matches and emits a connection event.\n      // When that happens, store that connection in the\n      // set of all connections for reference.\n      handler[kEmitter].on('connection', async ({ client }) => {\n        await clientManager.addConnection(client)\n      })\n\n      // The \"handleWebSocketEvent\" function will invoke\n      // the \"run()\" method on the WebSocketHandler.\n      // If the handler matches, it will emit the \"connection\"\n      // event. Attach the user-defined listener to that event.\n      handler[kEmitter].on(event, listener)\n\n      return handler\n    },\n\n    broadcast(data) {\n      // This will invoke \"send()\" on the immediate clients\n      // in this runtime and post a message to the broadcast channel\n      // to trigger send for the clients in other runtimes.\n      this.broadcastExcept([], data)\n    },\n\n    broadcastExcept(clients, data) {\n      const ignoreClients = Array.prototype\n        .concat(clients)\n        .map((client) => client.id)\n\n      clientManager.clients.forEach((otherClient) => {\n        if (!ignoreClients.includes(otherClient.id)) {\n          otherClient.send(data)\n        }\n      })\n    },\n  }\n}\n\n/**\n * A namespace to intercept and mock WebSocket connections.\n *\n * @example\n * const chat = ws.link('wss://chat.example.com')\n *\n * @see {@link https://mswjs.io/docs/api/ws `ws` API reference}\n * @see {@link https://mswjs.io/docs/basics/handling-websocket-events Handling WebSocket events}\n */\nexport const ws = {\n  link: createWebSocketLinkHandler,\n}\n\nexport { WebSocketData }\n"],"mappings":"AAAA,SAASA,SAAA,QAAiB;AAK1B,SACEC,gBAAA,EACAC,QAAA,QAEK;AACP,SAAeC,MAAA,QAAc;AAC7B,SAASC,sBAAA,QAA8B;AAEvC,SAASC,4BACPC,OAAA,EACiD;EACjD,OAAO,OAAOC,OAAA,CAAQC,GAAA,CAAIF,OAAA,EAAS,OAAO,MAAM;AAClD;AAEA,MAAMG,gBAAA,GAAmB,IAAIC,gBAAA,CAAiB,8BAA8B;AAE5E,IAAIL,2BAAA,CAA4BI,gBAAgB,GAAG;EAGjDA,gBAAA,CAAiBE,KAAA,CAAM;AACzB;AAuEA,SAASC,2BAA2BC,GAAA,EAA0B;EAC5Db,SAAA,CAAUa,GAAA,EAAK,mDAAmD;EAElEb,SAAA,CACEG,MAAA,CAAOU,GAAG,GACV,iEACA,OAAOA,GACT;EAEA,MAAMC,aAAA,GAAgB,IAAIV,sBAAA,CAAuBK,gBAAgB;EAEjE,OAAO;IACL,IAAIM,QAAA,EAAU;MACZ,OAAOD,aAAA,CAAcC,OAAA;IACvB;IACAC,iBAAiBC,KAAA,EAAOC,QAAA,EAAU;MAChC,MAAMC,OAAA,GAAU,IAAIlB,gBAAA,CAAiBY,GAAG;MAMxCM,OAAA,CAAQjB,QAAQ,EAAEkB,EAAA,CAAG,cAAc,MAAAC,IAAA,IAAsB;QAAA,IAAf;UAAEC;QAAO,IAAAD,IAAA;QACjD,MAAMP,aAAA,CAAcS,aAAA,CAAcD,MAAM;MAC1C,CAAC;MAMDH,OAAA,CAAQjB,QAAQ,EAAEkB,EAAA,CAAGH,KAAA,EAAOC,QAAQ;MAEpC,OAAOC,OAAA;IACT;IAEAK,UAAUC,IAAA,EAAM;MAId,KAAKC,eAAA,CAAgB,EAAC,EAAGD,IAAI;IAC/B;IAEAC,gBAAgBX,OAAA,EAASU,IAAA,EAAM;MAC7B,MAAME,aAAA,GAAgBC,KAAA,CAAMC,SAAA,CACzBC,MAAA,CAAOf,OAAO,EACdgB,GAAA,CAAKT,MAAA,IAAWA,MAAA,CAAOU,EAAE;MAE5BlB,aAAA,CAAcC,OAAA,CAAQkB,OAAA,CAASC,WAAA,IAAgB;QAC7C,IAAI,CAACP,aAAA,CAAcQ,QAAA,CAASD,WAAA,CAAYF,EAAE,GAAG;UAC3CE,WAAA,CAAYE,IAAA,CAAKX,IAAI;QACvB;MACF,CAAC;IACH;EACF;AACF;AAWO,MAAMY,EAAA,GAAK;EAChBC,IAAA,EAAM1B;AACR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}